#pragma once

// *********************************************************************************************************************
// Includes
// *********************************************************************************************************************

#include <cstddef>   // std::size_t
#include <typeinfo>  // hash_code

// *********************************************************************************************************************
// Namespaces
// *********************************************************************************************************************

namespace freddy::detail
{

// =====================================================================================================================
// Types
// =====================================================================================================================

class operation  // for caching
{
  public:
    auto operator()() const noexcept
    {
        return typeid(*this).hash_code() ^ hash();  // avoid identical hashes generated by related operations
    }

    friend auto operator==(operation const& lhs, operation const& rhs) noexcept
    {
        return typeid(lhs) == typeid(rhs) && lhs.equals(rhs);
    }

    operation(operation const&) = delete;

    auto operator=(operation const&) = delete;

    auto operator=(operation&&) = delete;  // since an operation is to be written directly to the CT

    virtual ~operation() noexcept = default;

  protected:
    operation() noexcept = default;

    operation(operation&&) noexcept = default;

    // ---- Abstract Methods for DD Operations -------------------------------------------------------------------------

    [[nodiscard]] virtual auto hash() const noexcept -> std::size_t = 0;  // computes a hash code

    [[nodiscard]] virtual auto equals(operation const&) const noexcept -> bool = 0;  // compares the operands
};

}  // namespace freddy::detail
